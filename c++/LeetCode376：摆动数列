题目：

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。

相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。

示例 1：

输入：nums = [1,7,4,9,2,5]
输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
示例 2：

输入：nums = [1,17,5,10,13,15,10,5,16,8]
输出：7
解释：这个序列包含几个长度为 7 摆动序列。
其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
示例 3：

输入：nums = [1,2,3,4,5,6,7,8,9]
输出：2
 

提示：

1 <= nums.length <= 1000
0 <= nums[i] <= 1000

思路：可以观察到如果是山峰或者山脚都可以构成摆动数列，我们可以定义一个数组path，将后一个数减去当前数的数值存放在此数组中。判断是否当前数和下一个数是否符号不同。如果不同说明就是摆动数列，最后考虑path数组0的关系。

第一步将返回的目标值和存放元素的数组定义完成，再通过一次遍历将两个数的差值存放数组中

        vector<int> vet;
        int pos = 2;
        for (int i = 1; i < nums.size(); i++)
        {
            vet.push_back(nums[i] - nums[i - 1]);
        }
ps：返回值初始化2，因为是遍历for（），少元素；再用减法后遍历，又少一个摆动数列的元素。
 

        for (int i = 1; i < vet.size(); i++)
        {
            if ((vet[i - 1] > 0 && vet[i] <= 0) || (vet[i - 1] < 0 && vet[i] >= 0))
            {
                if (vet[i] == 0 && ((vet[i - 1] < 0 && vet[i + 1] < 0) || (vet[i - 1] > 0 && vet[i + 1] > 0)))
                {
                    pos = pos - 1;
                }
                pos = pos + 1;
            }
            else
            {
                pos = pos;
            }
        }

如果 i 下标和i+1下标对应的元素符号不相同，说明是摆动数列，pos要+1。

如果符号相同，说明不是摆动数列，pos不变。

这里需要注意的一个点就是当vet元素出现【6，0，-6】时该怎么办，如果按照原来的思路结果pos总是比答案-1，就是这里出的问题，因为要求左边小于0或者右边小于0，这里因为0就少了一个pos+1,所以要在if（）语句中各在一边加入一个 =。

最后就需要考虑特殊情况，如果遇到【1，1，1，1】或者【1，7，4，5，5】都是AC不了的，这时候就需要特殊情况特殊对待了

        nums.erase(unique(nums.begin(), nums.end()), nums.end());
        if (vet.size() > 1)
        {
            if (vet[vet.size() - 1] == 0)
            {
                pos = pos - 1;
            }
        }
        if (nums.size() == 1)
        {
            pos = 1;
        }
完整代码：

class Solution
{
public:
    int wiggleMaxLength(vector<int> &nums)
    {
        vector<int> vet;
        int pos = 2;
        for (int i = 1; i < nums.size(); i++)
        {
            vet.push_back(nums[i] - nums[i - 1]);
        }
        for (int i = 1; i < vet.size(); i++)
        {
            if ((vet[i - 1] > 0 && vet[i] <= 0) || (vet[i - 1] < 0 && vet[i] >= 0))
            {
                if (vet[i] == 0 &&i!=vet.size()-1&& ((vet[i - 1] < 0 && vet[i + 1] < 0) || (vet[i - 1] > 0 && vet[i + 1] > 0)))
                {
                    pos = pos - 1;
                }
                pos = pos + 1;
            }
            else
            {
                pos = pos;
            }
        }
        nums.erase(unique(nums.begin(), nums.end()), nums.end());
        if (vet.size() > 1)
        {
            if (vet[vet.size() - 1] == 0)
            {
                pos = pos - 1;
            }
        }
        if (nums.size() == 1)
        {
            pos = 1;
        }
        return pos;
    }
};

————————————————
